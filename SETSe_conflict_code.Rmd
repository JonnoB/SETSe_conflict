---
title: "Untitled"
author: "Jonathan Bourne"
date: "24/07/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

The goal of this code is to test whether SETSe can integrate both the strength of relationships between people, the greater social network and the individual belligerents to predict the outcome of a conflict, or alternatively ascertain the strength of different relationship types from known outcomes.


#Set up
```{r Setup}

packages <- c("tidyverse", "igraph","readr","readxl", "broom", "stringr", "xtable", "rlang", "latex2exp", "yardstick", "minpack.lm", "ggraph", "patchwork", "rsample", "VGAM", "class", "mclust", "R.matlab", "ranger")

new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

select <- dplyr::select
arrange <- dplyr::arrange
map <- purrr::map
sapply(packages, library, character.only = TRUE)

library(rSETSe)

#Set up file system to read the correct folders this switches between aws and windows mode

#basewd <- "/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder"
LatexFolder <- "/home/jonno/Dropbox/Apps/ShareLaTeX/Sets Paper 1" 
FiguresFolder <- file.path(LatexFolder, "Figures")
TablesFolder <- file.path(LatexFolder, "Tables")
MatricesFolder <- file.path(LatexFolder, "Matrices")
PLwd <- "/home/jonno/setse_1_data"
CodeFolder <- "/home/jonno/SETSe_assortativity_and_clusters"
SubcodeFolder <- file.path(CodeFolder, "sub_code")

#Load some other useful functions
list.files("/home/jonno/Useful_PhD__R_Functions", pattern = ".R", full.names = T) %>%
  walk(~source(.x))


```

 
#simple case

This is a few toy examples to show that nodes with stiffer springs will have neighbouring nodes closer than nodes with less stuff springs. The purpose of these examples is to act as explainer and motivator for the idea that SETSe can predict conflict outcome or edge strenth

```{r}

```



#example conflicts
This section generates a number of networks using some method. It applies edge strengths and shows that consistant edge rules provide consistant results across randomly generated networks and node positions.

all experiments should comment on the comparison with betweeness centrality and also community detection techniques. This should show that SETSe can produce an outcome that the other methods can't

##Fixed edge strengths
This section uses fixed edge strengths for each relationship type.

generate network

If I generate 100 examples of each combination of agreement for all graph types, then plot the win ratio matrices for all combinations. This will show that certain subclasses have an advantage over others and this differs according to network topology.

I can then change the edge weights and repeat. this will show the importance of edge weights in the result.

```{r}

#What I want to know.
#fraction of total nodes? aka did they win?
#How many times?
#What about centrality?
#what about communitys

peels_class_k <- function(g, k_levels = c(1000, 500, 100)){
  
  g_df_vertices <- as_data_frame(g, what = "vertices")
  
  g_df_edges <- as_data_frame(g, what = "edges") %>%
    left_join(g_df_vertices, by = c("from"="name")) %>%
    left_join(g_df_vertices, by = c("to"="name")) %>%
    mutate(class_match = class.x == class.y,
           sub_class_match = sub_class.x == sub_class.y,
           k = case_when(
             class_match & sub_class_match ~ k_levels[1], #sub class match
             class_match & !sub_class_match ~ k_levels[2], #class amtch
             TRUE ~k_levels[3] #no match
             
           )) %>%
    {.[,c(1,2,9)]}
  
  g <- graph_from_data_frame(g_df_edges, directed = FALSE, vertices = g_df_vertices)
  
  return(g)
  
}

#first node is always positive
two_beligerent_conflict <- function(g, beligerents){
  
  force_vect <- rep(0, vcount(g))
  
  force_vect[beligerents] <- c(1,-1)
  
  g <- set.vertex.attribute(g, "force", value = force_vect)
  
  return(g)
  
}


two_beligerent_conflict <- function(g, beligerents){
  
  force_vect <- rep(0, vcount(g))
  
  force_vect[beligerents] <- c(1,-1)
  
  v_df <- as_data_frame(g, what = "vertices") %>%
    mutate(force = case_when(
      name == beligerents[1] ~1,
      name == beligerents[2] ~-1,
      TRUE ~0
      
    ))
  
  e_df <- as_data_frame(g, what = "edges")
  
  g <- graph_from_data_frame(e_df, directed = FALSE, vertices = v_df)
  
  return(g)
  
}



g <- generate_peels_network(type = "A") %>%
  remove_small_components() %>%
  peels_class_k(., k_levels = c(1000, 500, 100)) %>%
  prepare_SETSe_binary(
    node_names = "name",
    force_var = "class",
    positive_value = "A") 


#which nodes to compare against


#The first node of a_1 vs a_1 generally loses on type C why? It should be equal
#It doesn't matter if you reverse the nodes being choses
peels_results <- peel_conflicts(graph_types = LETTERS[1:5],
  beligerents =  tibble(node1 = c(1, 1,1,1, 11,11,11,21,21,31), 
                        node2 = c(2,11,21,31, 12,21,31,22,31,32)), #nodes to test
   k_levels = c(100,550,1000),
  samples = 100)


peels_results2 <- peel_conflicts(graph_types = LETTERS[1:5],
  beligerents =  tibble(node1 = c(1, 1,1,1, 11,11,11,21,21,31), 
                        node2 = c(2,11,21,31, 12,21,31,22,31,32)), #nodes to test
  k_levels = c(100,100,100),
  samples = 100)


peels_results3 <- peel_conflicts(graph_types = LETTERS[1:5],
  beligerents =  tibble(node1 = c(1, 1,1,1, 11,11,11,21,21,31), 
                        node2 = c(2,11,21,31, 12,21,31,22,31,32)), #nodes to test
  k_levels = c(100,5050,10000),
  samples = 100)



peels_results %>%
  ggplot(aes(x = clustering_elev_fract, y = betweenness_ratio)) + geom_point()


peels_results3 %>%
  ggplot(aes(x = paste(sub_class, sub_class2), y = clustering_elev_fract)) + geom_boxplot()+
  facet_wrap(~graph_type) + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))


test <- peels_results %>%
  group_by(graph_type, sub_class, sub_class2) %>%
  summarise_all(mean)



test <- peel_conflicts(graph_type = "E",
  beligerents =  tibble(node1 = c(1, 4), 
                        node2 = c(2, 34)), #nodes to test
   k_levels = c(100,550,1000),
  samples = 5)

peels_results3 %>%
  bind_rows(peels_results %>%
  rename(sub_class3 = sub_class, 
         sub_class = sub_class2) %>%
  rename(sub_class2 = sub_class3) %>%
    mutate(clustering_elev_fract = 1-clustering_elev_fract)) %>%
  ggplot(aes(x = sub_class, y = sub_class2, fill = clustering_elev_fract)) + geom_raster() +
  scale_fill_viridis_c()+
  facet_wrap(~graph_type)


saveRDS(test, file.path(PLwd, "peel_conflict.rds")  )


test <-bind_rows(peels_results %>% mutate(type = "10x"),
          peels_results2 %>% mutate(type = "1x"),
          peels_results3 %>% mutate(type = "100x"))

test %>%
  filter(graph_type != "A") %>%
  filter(sub_class != sub_class2) %>% #against self just isn't interesting 
  ggplot(aes(x = paste(sub_class, sub_class2), y = clustering_elev_fract, fill = type)) + geom_boxplot()+
  facet_wrap(~graph_type) + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))+
  scale_fill_brewer(type = "qual")





#every combination of node
combinations <- t(combn(1:40, 2))

peels_results <- peel_conflicts(graph_type = "C",
  beligerents = tibble(node1 = combinations[,1], 
                       node2 = combinations[,2]), #nodes to test
  k_levels = c(100,550,1000),
  samples = 1)


peels_results %>%
  ggplot(aes(x = node1, y = node2, fill = clustering_elev_fract>0.5)) + geom_raster()

peels_results_uniform <- peel_conflicts(graph_type = "C",
  beligerents = tibble(node1 = combinations[,1], 
                       node2 = combinations[,2]), #nodes to test
  k_levels = c(100,100,100),
  samples = 1)


performance_change <- peel_conflict_performance(peels_results, peels_results_uniform)

performance_change %>%
  ggplot(aes(x = rank, y = rank_uniform))+ geom_point()


performance_change %>%
  arrange(rank_change) %>%
  ggplot(aes(x = 1:40, y = rank_change))+ geom_point()

```
comparing the conflict of everynode to every other node allows us to find nodes that are better positioned for that network setup. either purely topologically or accounting for edge strength

comparing the same graph using different edge strength allows a direct comparison of the impact of edge strength.

We can then identify the nodes who experience the greatest relative strength change when accounting for edges and the point at which the switch occurs


randomly assign edge strengths
```{r}

```


##distribution edges

This shows the effect of using increaingly wide ranges of possible edge stiffnesses to predict the outcome of conflict.
I expect that when the uncertainty becomes larger the reliability drops.






#Conflict networks

This section looks at networks that experienced conflict and how the alliagieance of the network splits
all the data is from http://vlado.fmf.uni-lj.si/pub/networks/data/ucinet/UciData.htm#sampson
```{r}
files <- list.files("/home/jonno/setse_1_data/conflict_networks", full.names = T)
```


This is the thesis associated with a collection of schools dataset.
I don't know if there is any school level information available

https://search-proquest-com.libproxy.ucl.ac.uk/docview/304516167?pq-origsite=primo

data set available from; there are some problems with it.
http://moreno.ss.uci.edu/data.html

##Medici

The traditional metrics can check what would happen if we vary the strength of the different relationships
But only SETSe can vary the beligerents

This chunk shows that although the Strozzi have more power than the Albizzi, they would have lost in a congflict against the Medici, the Albizzi who although were split against and for the medici could have overpowered them if the strength of a mariage connection was no more than twice as valuable than a business connection. After that point the Albizzi lose badly.

The traditional metrics are identical for both of the conlfict types and in fact walktrap fails to separate the beligerents for large weights of marraige ties.

```{r}

#What is notable is that the medici can lose the conflict but are never less central  (lowwr betweeness) than the Strozzi or the Albizzi. This supports the simple case of a line of nodes where the centrality  of the nodes at each end is equal.

source(file = file.path(SubcodeFolder, "medici_process.R"))

AlbizziandStrozzi %>%
  filter(separate_success) %>%
  select(1:6, ratio) %>%
  pivot_longer(cols = 2:6, names_to = "metric", values_to = "values") %>%
    filter(metric !="ARI") %>%
  ggplot(aes(x = ratio, y = values, colour = name %>% str_remove(., "clustering_") %>% str_replace(., "_", " "), group = name)) + geom_path() +
  facet_wrap(~metric) +
  labs(title = "Medici vs Oligarchs using different power metrics",
       x = "Odds ratio of business to marriage weights",
       y = "Medici factional control",
       colour = "method") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
ggsave(file.path(FiguresFolder,  "medici_factional_controll.pdf"))       


set.seed(345)
g_medici %>%
  delete_vertices(., vertex_attr(., "name")=="PUCCI" ) %>%
  ggraph(.) + 
    geom_edge_link2( width = 0.7, edge_alpha =0.5) + 
      geom_node_point( aes(colour = party, 
                           size = ifelse(name == "MEDICI"| name =="STROZZI", 6,3))) + 
    scale_size_continuous(range = c(3, 6))+
  scale_edge_colour_viridis() +
  labs(title = "The factional alligiance of the Florentine families network") +
  guides( size = "none")+
geom_node_text(aes(label = name), nudge_y = .08)
ggsave(file.path(FiguresFolder,  "Medici_partisan_network.pdf"))

#the elevation and groups plot
# medici_strozzi$groups %>%
#   filter(marriage_weight == 300, business_weight == 100) %>%
#   ggplot(aes(x = node, y = elevation, colour = factor(party),
#              size = ifelse(node == "MEDICI"| node =="STROZZI", 6,3))) + geom_point() +
#   scale_size_continuous(range = c(3, 6))+
#   guides( size = "none") + 
#   theme(axis.text.x = element_text(angle = 25, hjust = 1))+
#   labs(title = "Medici vs Strozzi a tug of war with the families of Florence",
#        x = "Family",
#        colour = "Faction")

```

##Kapferer Mine

multiplex ties can be considered strong ties and uniplex considered weak ties.

Jackson is the boss
Lotson is the shop steward

Donald and Able worked as a pair
Abraham and Benson worked as a pair


What we learn from this dataset is that the imoprtance of the difference in weighting becomes explicit in SETSe whilst it is implicit in the the traditional clustering metrics. As such the weighting can be learned through multiple observations of interactions within graph structures, this weighting can then be deployed on new observations. This is beyond the scope of this paper!

Using a weighting of from 1to1 to 100to1 we find that the meta weight edges is an important concept to consider. Abraham does not overpower Donald in the full netowrk until multi edges are worth 5 times more than uniplex edges. This is important as edges of a multiplex network are often considered equally weighted but this may not be the case, as an example regular work contact is not necessarily as valuable in conflict as regular friendly contact.

Irrespective of the relation between uni adn multi edges Benson could never overcome Abel. What's more it required a higher weighting to for Abraham to overcome Abel, it thus appears the strategically most sensible move for Abraham to accuse Donald.

This information is not possible in a normal community detection algorithm which would always break the network into identical communities. The edge weights can be changed but this assumption has to be explicity stated using SETSe wheras the assumption is implicit in the other algorithms.

```{r}

source(file = file.path(SubcodeFolder, "kapferer_process.R"))
#SETSE separates the beliggerants everytime as expected, however the other methods can only achieve this on certain parameter settings. That said they do sucessfully show that the Abraham would have beet Donald. They are much less 
Kapferer_aggregated %>%
  left_join(kapferer_separation) %>%
  filter(value == "Abraham"| value == "Benson", 
        # cluster_method == "SETSe_kmeans",
        separate_success,
        cluster_method != "SETSe_kmeans"
         ) %>%
  ggplot(aes(x = ratio, y = fract, colour =str_remove(cluster_method, "clustering_") %>% str_replace(., "_", " "))) + geom_line() +
  coord_cartesian(ylim = c(0,1)) +
  facet_wrap( ~combo)+
  labs(title = "Resolution of the Kapferer mine conflict on graphs of different weights",
       y = "fraction of workers who side with Abraham/Benson",
       x = "The value of multiple edges compared to a single edge",
       colour = "method")
ggsave(file.path(FiguresFolder,  "Kapferer_mine_results.pdf"))

test <-Kapferer_aggregated %>%
  group_by(combo, 
           ratio,
           cluster_method) %>%
  summarise(separation_failure = sum(is.na(value)))


spec_res <- Kapferer_embeddings_results %>%
  filter(combo  == "Abraham-Abel",
         ratio ==10)

spec_res %>%
  ggplot(aes(x = node, y = elevation, colour = SETSe_kmeans,
              size = ifelse(node == "MEDICI"| node =="STROZZI", 6,3))) + geom_point() +
  scale_size_continuous(range = c(3, 6))+
  guides( size = "none") + 
  theme(axis.text.x = element_text(angle = 25, hjust = 1))

as_data_frame(kapferer_mine_g) %>%
  graph_from_data_frame(., directed = FALSE, vertices = spec_res ) %>%
    ggraph(.) + 
    geom_edge_link2( width = 0.7, edge_alpha =0.5) + 
    geom_node_point( aes(
      colour = SETSe_kmeans,
      size = ifelse(name == "Abraham"| name =="Donald", 6,3))
    )  +   
  scale_size_continuous(range = c(3, 6))+
    scale_edge_colour_viridis() +
    labs(title = "Kapferer mine conflict") +
    guides( size = "none")+
    geom_node_text(aes(label = name), nudge_y = .08)
  


```

##Thurman Office

A whole host of crazy happened here this is to test what I can do with it
```{r}
file_id <- grepl("thuroff", files)

emma_vs_ann <- thurman_office_function("ANN", "EMMA")
pete_vs_minna <-  thurman_office_function("PETE", "MINNA")
emma_vs_group <- thurman_office_function("EMMA", c("ANN", "AMY", "TINA", "KATY","LISA"))


test <- emma_vs_group$groups

bind_rows(emma_vs_group$summary %>% mutate(model = "emma vs group"),
          emma_vs_ann$summary %>% mutate(model = "ann vs emma"),
          pete_vs_minna$summary %>%mutate(model = "pete vs minna")
            
            ) %>%
  mutate(name = str_remove(name, "clustering_" )%>% str_replace(., "_", " ")) %>%
  ggplot(aes(x = ratio, y = fract, colour = name, group = name)) + geom_line() +
  facet_wrap(~model) +
  labs(title = "Predicted control using SETSe and traditional clustering methods", 
       x ="Odds ratio of business to personal weights",
       y = " fraction of nodes controlled") +
    theme(axis.text.x = element_text(angle = 55, hjust = 1))
ggsave(file.path(FiguresFolder,  "thurman_factional_control.pdf"))       

emma_vs_group$groups %>%
ggplot(aes(y = elevation, x = node, colour = elevation>0)) + geom_point()

emma_vs_ann$groups %>%
ggplot(aes(y = elevation, x = node)) + geom_point() +
    theme(axis.text.x = element_text(angle = 25, hjust = 1))


emma_vs_group$groups %>%
  filter(node=="PRESIDENT")

g_out %>%
ggraph(.) + 
    geom_edge_link2( width = 0.7, edge_alpha =0.5) + 
      geom_node_point( aes(
                           size = ifelse(name == "PETE"| name =="MINNA", 6,3))) + 
    scale_size_continuous(range = c(3, 6))+
  scale_edge_colour_viridis() +
  labs(title = "The factional allegiance of the Florentine families network") +
  guides( size = "none")+
geom_node_text(aes(label = name), nudge_y = .08)

```


#Sampson data
```{r}
g_dl <- load_dl_graph(files[7], directed = FALSE)


plot(g_dl[[3]])

names(g_dl)

```



#highschool

This is to see if using the highschool data I can generate more distinct results relateing to spring strength as the networks are actual social networks as opposed to random structures.

```{r}


set.seed(123)
g <- read_rds(file.path(PLwd, "highschool/graphs", "school_77.rds" ))  %>% simplify() %>% {
  set_edge_attr(., "k", value = sample(c(100, 1000), ecount(.), replace = T)) }


g_df <- as_data_frame(g, what = "vertices")

g <- g %>% 
two_beligerent_conflict(., beligerents = c(19, 23)) %>%
  prepare_SETSe_continuous(. , node_names = "name", force_var = "force")

results <- auto_SETSe(g)

sum(results$node_embeddings$elevation>0)
sum(results$node_embeddings$elevation<0)

```


	
	